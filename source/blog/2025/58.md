---
createTime: 2025/12/08 16:51:15
tags: ["Cursor"]
---

# 如何在 Cursor 中自定义智能体（Agent）？



我想在 Cursor 中像其他软件那样自定义 Agent 和使用，但很遗憾，没有找到。查了一下，网上有关于自定义的方法，但在最新版本的 Cursor 软件里就是找不到相关操作路径。



进一步查找，我在 Cursor 官方论坛里看到一帮用户在骂 Cursor：“你们竟敢擅自移除了 agent 自定义功能，告诉你们，这使我非常愤怒，我将把这个消息告诉我团队里的每一个人！”



我仔细翻了一下，论坛里骂得最凶的其实不是程序员，而是产品经理或设计人员。只有一位老哥说了他的实际感受：“我觉得斜杠命令并不错，它代替了原来的自定义智能体。” 原来自定义 agent 这个功能已经被 Cursor 拿掉了。



Cursor 工程师对此的回复是：“将自定义模式迁移至斜杠命令里，已经被广泛接受并认可。我们发现原来许多用户在自定义模式时，并不会添加工具，有的还会移除工具，这会导致产品体验变差。”



问题已经很清楚了，Cursor 中不能再自定义 agent 了，这个功能被官方拿掉了。我很高兴看到 Cursor 有此豪举，仅此一点就证明它特立独行，傲视群雄。其他软件有 agent 自定义功能不假，那是 Cursor 玩剩下的，它们怕只能跟在 Cursor 后面吃灰。



经过一番研究，Cursor 虽然没有了 agent 自定义功能，但通过四项功能可以达到甚至超过自定义 agent，这四项是：自定义斜杠命令、自定义规则、AGENTS.md 和 Hooks。



**自定义斜杠命令**



这是最简单的，在.cursor/commands 目录下定义一些 md 文件，每个文件里放置一些提示语，这就是自定义命令了，就可以在输入框里通过敲出斜杠调用它们了。命令这个词以后不再拘限于编程语言了，自然语言也可以定义命令。举一个例子吧：



> \# 代码审查清单
>
> 
>
> 用于进行全面代码审查的综合清单，确保质量、安全性和可维护性。
>
> 
>
> \## 审查类别
>
> 
>
> \### 功能性
>
> \- [ ] 代码按预期功能运行
>
> \- [ ] 边界情况得到处理
>
> \- [ ] 错误处理适当
>
> \- [ ] 无明显错误或逻辑问题
>
> 
>
> \### 代码质量
>
> \- [ ] 代码可读且结构良好
>
> \- [ ] 函数小而专注
>
> \- [ ] 变量名具有描述性
>
> \- [ ] 无代码重复
>
> \- [ ] 遵循项目约定
>
> 
>
> \### 安全性
>
> \- [ ] 无明显安全漏洞
>
> \- [ ] 存在输入验证
>
> \- [ ] 敏感数据处理得当
>
> \- [ ] 无硬编码密钥



所谓命令就是结构化的提示语。首先是一句话概括，接着是具体要求。如果说有什么要求，那要求就是符合 md 格式，一级标题下面是二级标题这样。



**自定义规则**



接下来介绍规则。命令是我们想执行时主动执行的，规则则是制定好规则自动执行的，它会在特定条件下自动触发。触发条件有四种：



> Always Apply 应用于每个聊天会话
>
> Apply Intelligently 当 Agent 根据描述判断其相关时
>
> Apply to Specific Files 当文件匹配指定模式时
>
> Apply Manually 当在对话中被 @ 提及时



规则定义使用的文件格式叫 moc，是一种元数据和内容混合的 md 格式。接下来我举几个例子，一起感受下上面四种情况是如何定义的。首先，针对特定目录下的特定文件生效这一种情况：



> \---
>
> description: "前端组件命名规则"
>
> globs: ["frontend/**/*.tsx", "components/*.ts"]
>
> alwaysApply: false
>
> \---
>
> \- 所有 React 组件必须使用 PascalCase 命名



这里的 globs 就是目录、文件规则，支持一些简单正则写法。



第二种，由 agent 动态判断：



> \---
>
> description: "React 组件开发规范"
>
> globs: []
>
> alwaysApply: false
>
> \---
>
> \- 所有 React 组件必须使用函数式组件
>
> \- 组件文件名采用 PascalCase 命名
>
> \- Props 类型必须使用 TypeScript interface 定义



此时 globs 是空的，而 alwaysApply 仍然是 false。



第三种，在提示语中被艾特提及：



> \---
>
> description: "对话中被 @ 提示时的响应规则"
>
> globs: []
>
> alwaysApply: false
>
> \---
>
> \- 当用户在对话中使用 @



看出来没有？此时 globs 还是空。globs 原意是 global patterns，是全局的匹配模式，指的就是目录、文件、文件类型的匹配规则，如果没有，就可以置空。



globs 的这种配置方式，与我们常见的配置真有点不同。在配置时，首先确定是不是全局有效，如果是，就写 alwaysApply 等于 true，否则写 alwaysApply 等于 false。接着看是不是特定目录特定文件有效？如果是，写在 globs 后面的括号里，如果不是，置空。由 agent 判断，是最宽泛的条件，任何时候 agent 都可以判断。至于被不被艾特，那是开发者的自由。整个匹配规则，其实只有两条。



moc 格式就这些，下面看规则的制定规则，只有一条：一个文件一个规则，如果要引用其他规则，可以用 @符号。



**AGENTS.md（代理说明）**



它是一种简单的、开放的、编码代理指导格式。这句话我不是原创，它被写在这里：



https://github.com/openai/agents.md



它像 README.md 现在已经成为了一种事实规范，已经被除了 Cursor 之外许多个 IDE 厂商支持了，像 Google CLI、Warp 等都有。但好像 TRAE、CodeBuddy 还没有，可能以后会有。



![图像](assets/G7oOxzza0AEnN5b.jpeg)



AGENTS.md 其实和以前自定义 agent 填写的那个提示语很像。以前是写在软件里，现在写在目录里；以前只能在一个地方写，现在在目录里可以写许多个，子目录还可以覆盖父目录，所以 Cursor 的这种方式其实是进步了，他们论坛上的争吵是由于少数产品经理、设计人士不懂。



撰写 AGENTS.md 基本和撰写 README 很像，用字简洁、结构清晰、逻辑严谨是第一原则。主要有四部分：



> 1，一句话概念项目是干什么的，添加Project overview，即项目概述
>
> 2，涵盖主要内容
>
> Build and test commands 构建和测试命令
>
> Code style guidelines 代码风格指南
>
> Testing instructions 测试说明
>
> Security considerations 安全考量
>
> 3，添加额外内容
>
> 例如提交消息或拉取请求指南、安全陷阱、大数据集、部署步骤。我们需要告诉新团队成员的一切内容也都应该在这里。
>
> 4，使用子目录



在子目录中也可以放置一份AGENTS.md，子目录可以覆盖父目录。



**Hooks（钩子）**



最后再提下钩子，它是真正的脚本了。前面都是提示语，只有钩子是精准的编程语言了。首先有一个.cursor/hooks.json 定义在什么时机执行什么脚本。下面是一个小示例：



> {
>
>   "version": 1,
>
>   "hooks": {
>
> ​    "afterFileEdit": [{ "command": "./hooks/format.sh" }]
>
>   }
>
> }



其次脚本是真正的脚本：



> \#!/bin/bash
>
> \# 读取输入，执行某些操作，退出码 0
>
> cat > /dev/null
>
> exit 0



钩子的执行时机，即与 afterFileEdit 同类的名称有许多，包含 agent 提示语执行前后、mcp 执行前后、文件读写前后等。



好，就聊这么多吧。通过梳理以上内容，我发现 Cursor 不是不支持自定义 agent 了，而是找到了一条比简单、粗暴定义 agent 更精细的道路。只有不懂编程的产品人员、设计人员才会对旧模式念念不忘，真正的工程师会马上拥抱这种新模式的。AGENTS.md 也必将成为事实标准，逐渐被所有 IDE 厂商支持。



Claude 模式问世后，推动了提示语结构化。现在，Cursor 的推广和普及，推动了 AI 配置的目录化，.cursor/hooks.json、.cursor/command/*、.cursor/rules/*、光明正大明文嵌套的 AGENTS.md，这些都是目录化的 AI 配置，以后这些东西会越来越多的，因为这种方式真的有效、高效。



📅 2025 年 12 月 8 日周一
